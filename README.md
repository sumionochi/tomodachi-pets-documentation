# Tomodachi Pets Game – AI-Powered On-Chain Virtual Pet Playground Documentation

| Resource          | Link                                                                                             |
| ----------------- | ------------------------------------------------------------------------------------------------ |
| Main Web App      | [Tomodachi Digital Pet](https://github.com/sumionochi/tomodachi-digital-pet)                     |
| Browser Extension | [Tomodachi Digital Pet Extension](https://github.com/sumionochi/tomodachi-digital-pet-extension) |
| Documentation     | [Tomodachi Pets Documentation](https://github.com/sumionochi/tomodachi-pets-documentation)       |
| Demo Video        | [Demo Video on YouTube](https://www.youtube.com/watch?v=E1rkjZkNquI)                             |

## Project Summary

Tomodachi Pets lets you draw or prompt custom pets/companions and their accessories, mint them as unique **Pet NFT** on the Sui network, personalize it with custom accessories generated by AI and bundle them onto your digital pets where they and selected assets will orbit around your cursor on any website! — all with full on-chain composability.

- **AI-Generated Accessories:** Draw or describe an accessory and let the AI (OpenAI’s GPT-Image-1 model) create a unique image for it.
- **NFT Minting & Composability:** Turn your creations into **NFT assets** on Sui, which can be equipped to or removed from your pet at any time.
- **Pet Customization:** Personalize your pet’s appearance with minted accessories and creative designs. All images and metadata are stored on **Walrus (decentralized storage)** for true on-chain ownership.
- **Daily Quizzes & Rewards:** Learn about Sui through daily quizzes. Complete a short quiz each day to unlock a **daily check-in** reward (in-game points).
- **Browser Extension Companion:** A Chrome extension that brings your pet to life outside the app – your pet (and its accessories) will follow your cursor around the web as a cute on-screen companion.

This project was built for the SuiOverflow Hackathon 2025 (Entertainment & Culture track) to showcase a fun, interactive experience that leverages **Sui’s object-centric design**, **decentralized storage**, and **AI creativity**.

## Repository Structure

The project consists of two repositories: the main web application and a companion browser extension.

### Main Repository: `tomodachi-digital-pet`

```
tomodachi-digital-pet/
├── move/                         # Sui Move smart contracts
│   ├── sources/
│   │   └── game.move             # Core Move module defining Pet, Asset, ScoreBoard, etc.
│   └── tests/
│       └── move_tests.move       # Test scenarios for the Move contract
├── src/
│   ├── app/
│   │   ├── page.tsx              # Next.js main page (React UI for game interface)
│   │   └── api/                  # Next.js API routes for backend logic
│   │       ├── upload/route.ts           # Handles image uploads to Walrus:contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}
│   │       ├── generate/route.ts         # Text-to-image generation via OpenAI API:contentReference[oaicite:2]{index=2}
│   │       ├── generatePetPreview/route.ts # Multi-image generation preview (AI)
│   │       └── editPetPreview/route.ts    # Image editing endpoint for sketch-to-image via OpenAI:contentReference[oaicite:3]{index=3}
│   ├── components/
│   │   ├── DailyQuiz.tsx         # Daily Quiz UI component (Q&A about Sui)
│   │   ├── AttributeInputList.tsx # Form component for adding NFT attributes
│   │   └── ui/                   # Reusable UI components (buttons, cards, dialogs, etc.)
│   ├── hooks/
│   │   └── gameHooks.ts          # Custom React hooks for querying game data (pets, assets, scores)
│   ├── lib/
│   │   ├── sui.ts                # Sui helper library (builds transactions for mint, equip, etc.)
│   │   ├── utils.ts             # Utility functions (e.g., formatting)
│   │   └── ...other helpers (localStorage, etc.)
│   └── (styles, config files, etc.)
├── public/                      # Public assets (icons, etc.)
├── package.json                 # Project dependencies (Next.js, Sui SDK, OpenAI, Walrus, etc.)
└── next.config.js, tailwind.config.js, tsconfig.json, etc.
```

**Notable dependencies:** The app is built with **Next.js 13** (React + TypeScript). It uses Mysten Labs’ Sui libraries (`@mysten/sui`, `wallet-kit` for wallet integration, and **@mysten/walrus** for storage) along with UI frameworks (Radix UI, Tailwind CSS) and the OpenAI SDK for AI image generation.

### Extension Repository: `tomodachi-digital-pet-extension`

```
tomodachi-digital-pet-extension/
├── src/
│   ├── popup/
│   │   ├── Popup.tsx            # React popup UI for user to enter Sui address, select pet, configure assets
│   │   └── popup.html, popup.css# HTML/CSS for the extension popup
│   ├── background/
│   │   └── background.ts        # Background script: handles messages, fetches pet data via local API:contentReference[oaicite:7]{index=7}:contentReference[oaicite:8]{index=8}
│   ├── content/
│   │   ├── content.ts           # Content script: injects pet overlay in pages, animates assets:contentReference[oaicite:9]{index=9}:contentReference[oaicite:10]{index=10}
│   │   └── content.css          # Styles for pet overlay (cursor-following image)
│   └── common/types.ts          # Shared type definitions (Pet, Asset metadata, message formats)
├── backend/
│   └── server.js                # Express server to query Sui RPC for pet/assets:contentReference[oaicite:11]{index=11}:contentReference[oaicite:12]{index=12}
├── icons/                       # Icons for the extension (16x16, 48x48, 128x128)
├── manifest.json                # Chrome extension manifest (permissions, content script registration):contentReference[oaicite:13]{index=13}:contentReference[oaicite:14]{index=14}
├── webpack.config.js            # Build configuration for the extension (bundles content, popup, background):contentReference[oaicite:15]{index=15}
└── package.json                 # Extension’s dependencies (uses Sui JS client, React)
```

**Key extension components:** The extension consists of a **Popup UI** (for user input and settings), a **Background Script** (which performs data fetching and persists state), and a **Content Script** (which renders the pet and accessory images on every webpage). There is also a simple Node/Express **local backend** (`backend/server.js`) that the extension calls to query on-chain data (to avoid direct RPC calls from the content script).

## Technology Stack

- **Frontend:** Next.js 13 (App Router) with React 19 and Tailwind CSS. UI leverages Radix UI for accessible components (modals, menus, etc.).
- **Blockchain:** Sui blockchain (Move smart contracts). Uses Mysten Labs’ Dapp Kit and Sui SDK for integration. The Move contract (`game.move`) defines the game logic on-chain.
- **Wallet Integration:** Uses Sui Wallet Kit to connect to Sui wallets. Players sign transactions (create pet, mint asset, equip asset, etc.) directly in their wallet.
- **Storage:** **Walrus Protocol** by Mysten for decentralized blob storage. Images (pet accessories) are uploaded via Walrus so that they are stored off-chain but referenced on-chain (ensuring data availability and ownership).
- **AI Generation:** Integrates with OpenAI’s image generation API. Uses the model `gpt-image-1` (capable of text-to-image and image editing) via the official OpenAI Node SDK. This enables both **text-to-image** generation and **sketch-to-image** editing.
- **Browser Extension:** Built with TypeScript and React, bundled via webpack. Utilizes Chrome extension APIs (storage, messaging, content scripts) and the Sui JavaScript client for data fetching.

## System Architecture

The system is composed of several interacting components: the user-facing web app, on-chain smart contracts (Sui), off-chain storage (Walrus), AI services, and the browser extension. The diagram below illustrates how these pieces communicate:

![system design](https://github.com/user-attachments/assets/663b441d-7fa3-4c8e-bc8e-a48571e09ec6)

![Static to dynamic (1)](https://github.com/user-attachments/assets/9b869403-3332-468a-90b8-36dc31afa917)

&#x20;_System architecture of Tomodachi Pets. The Next.js web app interacts with the Sui blockchain (smart contracts) for game actions and uses OpenAI for image generation. Images are uploaded to Walrus decentralized storage, and the resulting links are stored on-chain. A browser extension (with a local backend) fetches on-chain data via Sui RPC to display the pet across webpages._

In this architecture, the **Web App** is the central hub for user interactions, handling gameplay logic in the UI and coordinating between blockchain and off-chain services:

- **Web App ↔ Sui Blockchain:** All game actions that need persistence or trust (creating a pet, minting an asset, equipping/unequipping items, daily check-in) are **Move contract calls** executed on the Sui network. The web app uses the user’s wallet to sign these transactions.
- **Web App ↔ OpenAI API:** For generating accessory images. When a user requests an AI-generated accessory, the app calls OpenAI’s image generation endpoint with the user’s prompt and desired parameters (1024x1024, transparent background). The OpenAI **GPT-Image-1** model returns a base64-encoded image.
- **Web App ↔ Walrus Storage:** For storing images on-chain. After generation or user upload, images are sent to a Walrus **publisher node** via an HTTP API. The app receives back a `blobId` and constructs a content URL for the image. This URL (pointing to Walrus’s decentralized storage) is what gets saved on-chain in the Asset’s metadata.
- **Browser Extension ↔ Local Backend ↔ Sui:** The extension’s background script communicates with a lightweight Express server (`backend/server.js`) running on the user’s machine (or a provided endpoint). This local service uses the Sui SDK to fetch the user’s pet and asset objects directly from the blockchain. The extension then displays those images by retrieving the image URLs (from Walrus) stored in the on-chain asset objects.

All images and metadata reside on decentralized infrastructure (Walrus + Sui), ensuring the pet and accessories are **fully on-chain and user-owned**. The use of Sui’s object model means the Pet and its Accessories are actual on-chain objects/NFTs, enabling the composable behavior described below.

## Sui Smart Contracts: On-Chain Pet & Asset Logic

At the heart of Tomodachi Pets is a Move module (`game.move`) that defines how pets and assets are created and managed on the Sui blockchain. Key aspects of the contract include:

- **User Registration & Points:** A global `ScoreBoard` object tracks each player’s points (score). New users register via `create_user`, which initializes their score to 100 points. A `check_in` function implements the daily reward: it uses Sui’s clock to ensure 24 hours have passed since the last check-in, then awards +2 points and records the timestamp.

<img width="1398" alt="image" src="https://github.com/user-attachments/assets/c0885eb2-961a-4ecc-8b4b-ec72be9651e1" /> </br>
Figure 1: Get 10 points/scores for registering in game and continue to earn +2 points every daily check-in.

<br><br>

<img width="1134" alt="image" src="https://github.com/user-attachments/assets/023ce1df-45af-4153-89cc-d75dc45bc100" /> </br>
Figure 2: Complete Daily Quiz on Sui, walrus, Move contracts to claim +2 daily check-in prize.

<br><br>

<img width="1075" alt="image" src="https://github.com/user-attachments/assets/85d3f5d1-e770-431c-8d4f-df9806f7ba02" /> </br>
Figure 3: Claim Reward after completing Daily Quiz.

<br><br>

<img width="1244" alt="image" src="https://github.com/user-attachments/assets/390e07aa-e7d3-40fb-a6a0-c0dde48419d9" /> </br>
Figure 4: The sui::Clock ensures that every 24hr only new +2 points for daily claim and Daily Quiz is available.

<br><br>

- **Pet NFTs:** A `Pet` is a Move struct with a unique name field. Players create a pet by calling `create_pet` (once per user) which mints a new `Pet` object/NFT if the name is not already taken (enforced via a `PetNames` table). Pet objects are storable, transferrable NFTs (owns itself via a UID).

<img width="1193" alt="image" src="https://github.com/user-attachments/assets/fcc40207-ee9f-443c-af8d-7190ae4c8201" /> </br>
Figure 5: Minting a unique pet name for which assets, animation and accessories will be equiped too.

<br><br>

<img width="379" alt="image" src="https://github.com/user-attachments/assets/866d3bf9-e922-42ac-a74b-f2b68196e9c6" /> </br>
Figure 6: Here a minted pet name with unique ID.

<br><br>

<img width="1158" alt="image" src="https://github.com/user-attachments/assets/befbe927-fe3f-450e-b4ba-631a5b4ff0db" /> </br>
Figure 7: Generating Assets to equip to pet name such that player can upload specific image and generate one.

<br><br>

<img width="886" alt="image" src="https://github.com/user-attachments/assets/1cc94f82-ef7b-4446-907f-d65618f08e35" /> </br>
Figure 8: Utilize all the images to refine into a single pet or asset for accessory or animation.

<br><br>

<img width="1229" alt="image" src="https://github.com/user-attachments/assets/7a4545ff-a7fb-4990-83d2-5f432da42ec7" /> </br>
Figure 9: Perfect combination of traits as pet static image is generated which if ready for final preview and minting.

<br><br>

<img width="301" alt="image" src="https://github.com/user-attachments/assets/7bdc071f-028e-404a-9f39-bbc461bfd550" /> </br>
Figure 10: Enter Meta Data details for the NFT we are going to generate to be available for equiping to a pets name.

<br><br>

<img width="863" alt="image" src="https://github.com/user-attachments/assets/c225976a-c5e3-44dc-ac7f-df7ec78e60ba" /> </br>
Figure 11: The assets of static pet is ready for equiping to unique pet name.

<br><br>

- **Accessory NFTs (Assets):** Accessories are represented by an `Asset` struct with rich metadata: a `name`, `description`, arbitrary `attributes` (stored as a JSON string), an `action` code and `frames` (for animation info), and importantly a `url` field that holds the **Walrus blob URL** for the image. When a user mints a new accessory via `mint_asset`, the contract deducts 10 points from their score (PRICE_ASSET = 10) and creates a new `Asset` object, storing the image URL and metadata on-chain. The new asset NFT is then transferred to the user and recorded in a `MintRecord` table under the user’s address.

<img width="862" alt="image" src="https://github.com/user-attachments/assets/f32a8b76-8f4e-43d8-8c3d-3018d35fe051" /> </br>
Figure 12: We have now generated all the accessories and animation frames for our Equipment in any Pet.

<br><br>

<img width="915" alt="image" src="https://github.com/user-attachments/assets/5eb0d6c3-97fe-4776-9f8c-817b4a4cb68e" /> </br>
Figure 13: Player can download or use select to equip to any Unique Pet name.

<br><br>

- **Composable NFTs – Equip/Unequip:** Tomodachi Pets leverages Sui’s object composability. The Move module allows an `Asset` (accessory NFT) to be **dynamically linked** to a `Pet` object, effectively equipping the item. The `equip_asset` function attaches an asset to a pet using Sui’s **dynamic object field** mechanism. It first checks a global map to ensure no pet is already wearing that asset (each asset can only be equipped to one pet at a time), then marks it equipped and adds it as a child object of the Pet. The asset’s ownership is transferred to the Pet object (so it no longer appears in the user’s wallet directly, but as part of the Pet’s data). Conversely, `unequip_asset` removes the asset from the pet, transfers ownership of the asset NFT back to the user, and updates the tracking maps accordingly. This design showcases Sui’s native composability: the Pet is like a container that can own other NFT objects. Equip and unequip actions emit events (for potential off-chain indexing) when they occur.

<img width="851" alt="image" src="https://github.com/user-attachments/assets/e39bdb13-a716-4fed-bffc-1cb19fd64687" /> </br>
Figure 14: Select the Unique Pet name to open it for asset equipment.

<br><br>

<img width="1056" alt="image" src="https://github.com/user-attachments/assets/db8776db-b1de-419b-8fef-e30e66a1fa9d" /> </br>
Figure 15: Approve and equipe multiple assets to a unique pet.

<br><br>

<img width="887" alt="image" src="https://github.com/user-attachments/assets/e5df5e77-9189-4880-a41c-0c4ab8f2f090" /> </br>
Figure 16: All assets are unique to pets.

<br><br>

- **Admin Capabilities:** The contract also defines an `AdminCap` (held by the deployer) which, in a hackathon context, was used for testing (e.g. an `admin_set_score` function to arbitrarily set player scores).

<img width="785" alt="image" src="https://github.com/user-attachments/assets/fcbab39c-cbe1-4ea6-88a3-bdd54a60954b" /> </br>
Figure 17: Only the deployer of contract receives adminCap to set any players score at will.

<br><br>

<img width="1048" alt="image" src="https://github.com/user-attachments/assets/72de552e-a8d8-40ac-9c1d-8c6f5485ce56" /> </br>
Figure 18: Insert any players score and user Address for Admin to change.

<br><br>

Overall, the Move contract encodes game rules (points system, unique naming, item equipping constraints) directly on-chain. Sui’s storage model (with global objects and dynamic fields) is used to ensure that a given accessory NFT cannot be duplicated or equipped on multiple pets simultaneously, etc., enforcing the game logic at the smart contract level.

## Walrus Integration (Decentralized Storage of Images)

Walrus is Mysten Labs’ decentralized storage solution for Sui, used in Tomodachi Pets to store all pet and asset images off-chain while keeping them accessible and provably linked on-chain. The web app integrates Walrus as follows:

- **Uploading Images:** When an accessory image is finalized (whether drawn by the user or AI-generated), the frontend calls a Next.js API route `/api/upload`. This route takes a base64-encoded image, converts it to binary, and sends a **HTTP `PUT` request** to the Walrus **Publisher** service. The app includes Walrus configuration in env (e.g. `NEXT_PUBLIC_WALRUS_PUBLISHER_URL` for the endpoint). On success, Walrus returns a JSON containing a unique `blobId` for the stored image.

<img width="1009" alt="image" src="https://github.com/user-attachments/assets/cfe39c50-6b77-49ef-aed5-50b52cf9ba19" /> </br>
Figure 18: the finalized base64-encoded image is converted to binary -> Walrus publishes with publisher service. And player can access the image through and aggregator service.

<br><br>

- **Forming On-Chain URLs:** Given the returned `blobId`, the app constructs a content address (URL) that any Walrus node can serve. For example, it may combine a base URL with the blobId (e.g. `https://blobs.testnet.walrus.network/<blobId>`). This URL is then passed into the Move transaction when minting the Asset NFT. The `mint_asset` function saves this string in the Asset’s `url` field on-chain. By storing the link in the NFT, _anyone_ can retrieve the image from Walrus using that URL, and the data is content-addressed and backed by Walrus’s decentralized network.
- **On-Chain Metadata:** In addition to the image URL, other metadata (name, description, attributes JSON) are stored directly in the Asset object on-chain. This means the full definition of each accessory NFT (image + metadata) lives in a decentralized manner (on Sui + Walrus). The README of the NFT in Sui’s object display can even include the image (if a wallet or explorer supports reading the `url` or display fields).
- **Benefits:** Using Walrus gives the project a Web3-native way to handle assets that would be too large or costly to store directly in a Move object. It provides **decentralized content storage** (no reliance on centralized servers for images) and works seamlessly with Sui (the Walrus blobId could be verified or content-hash-checked by contracts if needed). From the user’s perspective, images load just like any URL, and behind the scenes Walrus ensures the data is distributed and available.

In summary, Walrus allowed us to keep Tomodachi Pets **fully on-chain** in spirit: every pet/accessory’s image is stored in a decentralized blob and referenced in the Sui NFT, rather than just keeping a centralized URL or IPFS hash that might not be persisted. This aligns with the project’s goal of true user ownership of their pet and its assets.

<img width="1030" alt="image" src="https://github.com/user-attachments/assets/78b37113-9139-4bb2-a78a-d7ce3d488e38" /> </br>
Figure 19: Walrus responds with a blobId for our published image and hence our asset is minted.

<br><br>

## AI Service Integration (GPT-Image-1 for Accessories)

A standout feature of Tomodachi Pets is the **AI-generated artwork** for pet accessories. By integrating OpenAI’s image generation capabilities, the project enables users to create unique visuals for their NFTs in a fun, interactive way:

<img width="873" alt="image" src="https://github.com/user-attachments/assets/4b4bd874-1443-410b-83c1-363998474d40" />

- **Text-to-Image Generation:** Users can input a description of an accessory they imagine (e.g. “a red cowboy hat with gold trim” or “wizard hat with stars”). When the user clicks _Generate_, the app calls the `/api/generate` route, which uses the OpenAI SDK to request an image from the `gpt-image-1` model. The request specifies a 1024×1024 image, and a transparent background if needed (ideal for layering accessories). The OpenAI service returns a base64-encoded PNG image which the app converts to an `<img>` preview for the user.
- **Sketch-to-Image (AI Editing):** For users who prefer drawing, Tomodachi Pets provides a canvas (built with `react-sketch-canvas` and Konva). A user can sketch an outline of an accessory (for example, drawing the shape of a hat). They can then provide a brief prompt and use the AI _edit_ feature. The app will send the sketch along with the prompt to the `/api/editPetPreview` route, which calls OpenAI’s image editing endpoint. This uses `gpt-image-1` in edit mode, sending the sketch as an input image (and an optional mask) along with the prompt. The AI then returns a new image that **retains the user’s sketch structure but applies AI-generated details**. This is perfect for users with ideas who want the AI to do the polishing – for example, drawing a rough crown and having the AI produce a shiny golden crown image.
- **Multi-Image Previews:** The `generatePetPreview` route can even fetch multiple candidates (using OpenAI’s `n` parameter) so the user might get 2-3 variations of an accessory and pick their favorite to mint.
- **OpenAI Model (GPT-Image-1):** This is a cutting-edge image generation model (related to DALL·E family) that accepts natural language and/or image inputs. It was chosen for its ability to understand detailed prompts and produce high-quality, 1024×1024 images with support for transparency. Using OpenAI’s hosted API allowed fast integration – the team just needed an API key and the OpenAI Node library, and I were generating images within minutes of coding.
- **In-App Integration:** The UI provides a smooth experience around the AI features. After generation, the new image is shown in an preview list. Users can refine it (e.g. re-generate with a different prompt or edit further) or finalize it. Upon finalizing, the image data is uploaded to Walrus and then included in a mint transaction to become a permanent on-chain asset.
- **Fallback to Manual Upload:** Users are not forced to use AI; they can also upload an image or use the drawing as-is. The `/api/upload` endpoint (discussed above with Walrus) handles any base64 image (AI-generated or manually created).

This AI integration adds a **“wow” factor** – even non-artists can create personal, one-of-a-kind accessories for their pet. It also perfectly fits the theme of creativity in the Entertainment & Culture track. In technical terms, it demonstrates how Web3 applications can incorporate Web2 AI services to enhance user experience, all while still keeping the final assets decentralized and on-chain.

## Core Gameplay Flow

Bringing together the smart contract and off-chain logic, the core game loop can be described as follows:

<img width="864" alt="image" src="https://github.com/user-attachments/assets/7d5abb91-da30-4b8d-802d-427708511557" /> </br>

&#x20;_Daily engagement and creation flow in Tomodachi Pets. Each day, the user can complete a quiz and perform a check-in to earn points. Accumulated points are spent to mint new accessory NFTs. Users design accessories with the help of AI (generating images), mint them on-chain (burning points), and equip them to their Pet NFT. The Pet with its equipped assets can then be seen both in the web app and via the browser extension._

1. **Daily Quiz & Check-In:** Each day the user is presented with a set of multiple-choice quiz questions (fun facts about Sui and crypto). After answering, the **Daily Check-In** button becomes available. When clicked, it triggers a `check_in` Move call, which verifies the 24-hour interval and then increments the user’s score by +2 points. This encourages daily return and also educates the user (the quiz content doubles as a learning tool about Sui).
2. **Designing an Accessory:** The user decides to create a new accessory for their pet. They can either free-draw it on the canvas or write a text description. Using the integrated AI tools (as described above), the user iterates until they have an image they like. This image is shown on the screen as a preview.
3. **Minting the Accessory NFT:** With a satisfactory design ready, the user mints it as an NFT by clicking the **Mint** action. Under the hood, the app uploads the final image to Walrus (getting a blobId and URL) and then calls the Move `mint_asset` function. The transaction includes the Pet’s name, description, and attributes, as well as the Walrus image URL. The contract deducts 10 points from the user’s score (ensuring they have enough) and creates the new Asset object linked to the user. On the frontend, the user’s point total is updated and the new accessory appears in their inventory.
4. **Equipping the Accessory:** Now the user can equip this item to their pet. They select their pet and the new asset, and the app calls `equip_asset`. The wallet prompts a transaction, and on success, the Asset NFT is now attached to the Pet NFT on-chain. In the UI, the pet’s image is layered with the accessory’s image (since I know the asset’s URL, I can display it over the pet).
5. **Iterate & Play:** The user can continue to earn points daily and create more accessories. They might unequip or swap accessories to change their pet’s look at any time (these are also transactions, but free of cost). A scoreboard (leaderboard) is available via `useScoreboard` hook to show top points holders, adding a bit of gamification.

The loop above emphasizes **engagement**: daily activity yields points, which fuel creativity and customization. Because everything except the quiz is on-chain, users truly own their pets and accessories and could even trade them (each accessory is an NFT in their wallet when unequipped, and the pet itself is an NFT). The game logic prevents abuse (like no double-check-in thanks to on-chain timestamp tracking, and no equipping the same item twice).

## Browser Extension: Pet Companion on Every Page

One of the most delightful features is the Tomodachi Pets **browser extension**, which brings your pet into the wider web. Once installed, the extension spawns an animated pet overlay that follows your cursor as you browse any website, providing a constant companion. Here’s how it works and what it offers:

- **Architecture:** The following diagram shows the extension’s internal message flow:

![img3](https://github.com/user-attachments/assets/98585c25-f3b6-4f66-9c7b-2efe03378c6b) </br>

&#x20;_Browser Extension architecture and data flow. The extension consists of a Popup UI (for user input and settings), a Background script (handling data fetch and state), and a Content script (rendering the pet on web pages). The background script communicates with a local Node.js API which fetches on-chain pet and asset data via Sui RPC. The content script listens for updates and draws the pet & accessory images on every page, following the user’s cursor. Users can toggle visibility or switch assets via the popup (messages shown by arrows)._

- **User Setup:** In the extension’s popup UI, the user enters their Sui address (the one holding their Pet NFT). The extension then queries the blockchain (via the local backend) to fetch the list of Pet objects owned by that address. If the user has multiple pets (in this game typically one), they can select which pet to display.

<img width="940" alt="image" src="https://github.com/user-attachments/assets/a25a5ad3-a023-44ed-8dc2-91965e593715" /> </br>
Figure 20: Add user address and choose through the names of pets available to fetch its equipped assets.

<br><br>

- **Live Data Fetching:** When the user clicks “Save & Fetch” in the popup, the background script uses the address (and selected pet ID) to request pet info. It calls the local Express server’s `/api/user-pet` endpoint, passing in the address and pet ID. The server uses the Sui JavaScript client to retrieve the Pet object and any equipped Asset objects (via `suiClient.getDynamicFields` to list child assets). It then returns structured data about the pet and its assets (including the image URLs stored on-chain).

<img width="949" alt="image" src="https://github.com/user-attachments/assets/2911cd21-d5ec-431f-89bd-01b41a694cc8" /> </br>
Figure 21: The Assets are fetched and available to be picked from. Multiple assets and action can be rendered at once around the cursor.

<br><br>

- **Rendering the Pet:** The content script, which runs on every page, receives the pet data (via Chrome messaging or storage updates) and either creates or updates a floating `<div>` on the page that contains the pet’s image and accessory images. If the Pet NFT had an image URL (not currently, since Pet has no image field by default), it would show that; otherwise it just displays the pet’s name or a default icon as the base. Then for each _equipped_ accessory, it loads the accessory’s image (using the Walrus URL in the asset data) and renders it in the overlay as well. The assets can be styled or positioned relative to the pet – e.g. an asset might have an `action` that indicates if it should orbit around the pet or stay fixed.

<img width="317" alt="image" src="https://github.com/user-attachments/assets/877eebd3-d28b-4ea4-9a15-c9b1fbc9a1d0" /> </br>
Figure 22: Assets can be choosen between static with set duration of render or animated wich will slice the image into 4 parts to render continously 4 frames looking like the pet is performing an action like walking and eating.

<br><br>

<img width="796" alt="image" src="https://github.com/user-attachments/assets/cd9f15c7-fc42-4de4-bf22-a719c9a392e2" /> </br>
Figure 23: Pet with its name and performing action of eating carrot.

- **Following the Cursor:** The content script attaches an event listener to track mouse movements. The pet container `<div>` is absolutely positioned so that it hovers over the page content. On every `mousemove`, the script updates the container’s position to follow the cursor (with a slight offset). This makes the pet float alongside the cursor as you move.

<img width="842" alt="image" src="https://github.com/user-attachments/assets/53450213-9a3a-4749-beeb-8223c1ffaf21" /> </br>
Figure 24: On another site Pet with its name and performing action of walking by rendering 4 continous frames from spritsheet.

<br><br>

- **Accessory Animations:** The extension allows some simple animations. For example, if an asset NFT has multiple animation frames (the `frames` field > 1), the extension can treat the image as a sprite sheet. In the content script, if an asset is marked with `mode: "animated"`, it will create a canvas and cycle through sub-images as frames. The frame count and frame rate can come from the asset metadata (the `frames` field and perhaps an attribute). This way, a user could create an animated accessory (like fluttering wings or a blinking hat) by uploading a sprite sheet – the extension will animate it on the page.

<img width="825" alt="image" src="https://github.com/user-attachments/assets/dc4bbda6-c35f-444c-944d-07c4cd375712" /> </br>
Figure 25: Equip and choose another pet to perform different action and render different assets. All for players immagination.

<br><br>

- **User Controls:** Through the popup, the user can configure which assets to display. The extension lists all assets (equipped or in inventory) and the user can toggle them on/off as part of the “orbit.” The extension supports showing one or multiple accessories at once; currently it cycles through selected assets one at a time (to avoid cluttering the screen). Users can also toggle the entire pet on/off quickly (there’s a hotkey Ctrl+Shift+P to hide/show the pet, implemented in the content script). All settings are saved to `chrome.storage` so they persist.

As shown, the extension bridges the on-chain world with a user’s browsing experience. It uses relatively simple tech (Chrome extension APIs, an Express server, Sui client calls) to achieve a whimsical result: your NFT pet is not confined to a marketplace or app – it can accompany you anywhere on the internet! This feature showcases **“experience beyond the dApp”**, adding a wow factor that is memorable for users and hackathon judges alike. It’s also a proof-of-concept for how blockchain assets can be made interactive and present in everyday web usage.

## User Flows & Journeys

To ensure Tomodachi Pets is enjoyable and user-friendly, I designed clear user flows for common actions. Below are a few example journeys from the user’s perspective:

<img width="1075" alt="image" src="https://github.com/user-attachments/assets/69d7bd57-ca33-4903-bc89-d1350ed0f62b" />

- **🐣 Creating Your Pet:** A new user lands on the app, connects their Sui wallet, and chooses a pet name. When they hit “Create Pet,” a transaction is sent to call `create_pet`. If the name is unique, the transaction succeeds and a Pet NFT is minted into their wallet. The UI updates to show their pet’s name on the dashboard. (Under the hood, their address was also registered in the ScoreBoard with 100 starting points during registration, if not already registered).
- **🎨 Designing and Minting an Accessory:** The user navigates to the **Assets** tab to create a new accessory. They draw a rough shape in the canvas and type “green wizard hat”. After clicking _Generate_, an AI-generated hat image appears. They refine the prompt and get an even better image on the second try. Satisfied, they click _Mint Accessory_. The app uploads the image to Walrus and calls `mint_asset`. The user confirms the transaction (burning 10 points). In seconds, their new “Wizard Hat” NFT is minted on Sui and now visible in their asset list.
- **👒 Equipping an Accessory:** In the **Pets** tab, the user sees their pet and a list of owned accessories. They select the “Wizard Hat” and click _Equip_. This triggers an `equip_asset` transaction. The extension and web app both update: the pet now appears with a wizard hat on its head. (If the user checks their wallet, they’ll see the Asset NFT is now a child of the Pet object, not a standalone object).
- **📅 Daily Quiz & Check-In:** The next day, the user returns to find new quiz questions available. They answer the 3 multiple-choice questions (learning a few facts from the explanations). Now the “Daily Check-In” button lights up – they click it, sign the transaction, and get a toast notification: “Success! +2 points earned.” Their points on the scoreboard increment, getting them closer to the next accessory mint.
- **🌐 Using the Pet Extension:** The user installs the Chrome extension. In the popup, they paste their Sui address and hit fetch. Their pet’s name appears along with the equipped “Wizard Hat” asset. They turn on a toggle for another accessory (say, a “Sword” they minted earlier) to also display. As they continue browsing Reddit or Google, their Tomodachi pet is frolicking on the pages – a wizard hat on its head and occasionally swinging a sword! If they need a break or a site has an overlay, they press Ctrl+Shift+P to hide the pet, then toggle it back on later. The pet becomes a fun little companion and a constant reminder of the game.

Each of these flows was implemented with attention to **UX**: I use toasts and status indicators (via the Sonner library) to give feedback on transactions, and I persist data (using React Query + localStorage) so that, for example, returning users see their last pet and asset selections without reloading everything.

## Hackathon Pitch Highlights

Tomodachi Pets is more than just a demo – it’s a **fully working prototype** that hits all the notes of the Entertainment & Culture track:

<img width="1093" alt="image" src="https://github.com/user-attachments/assets/aa0935c5-d784-454e-add8-f39efcd13af2" />

- **Original Concept & Fun Factor:** The project combines the nostalgia of Tamagotchi/digital pets with blockchain collectibles and AI creativity. It stands out as an original idea – instead of a typical DeFi or marketplace project, it’s a playful experience that can appeal to mainstream users. The browser extension in particular adds a delightful twist that most wouldn’t expect from an NFT hackathon project.
- **Completeness & UX:** I aimed to deliver a complete user journey. From creating a pet, to earning points through quizzes, to minting and equipping accessories, to experiencing the pet in a browser extension – the app covers a lot of ground. The interface is designed to be approachable (no code or manual transactions needed beyond wallet clicks). For hackathon demo purposes, I also made sure to seed some quiz content and have sensible defaults to showcase the flow (e.g., initial points given). Multiple components (web app + extension) work in tandem, demonstrating good polish.
- **Technical Difficulty & Sui-Native Features:** Under the hood, this project wasn’t easy! I wrote a custom Move smart contract leveraging Sui’s unique features like **object ownership and dynamic fields for composability**, as well as looked into Sui Event emitting. I integrated **Walrus** – a very new piece of tech – to handle storage, showing I can push the envelope beyond standard NFTs. I also used the Sui JS client in a novel context (a browser extension’s local backend) to pull dynamic field data. All of this shows a deep understanding of Sui and an attempt to use it creatively (not just as a wallet login or simple token).
- **Use of AI:** By incorporating AI generation (and even editing with sketches), I add a cutting-edge element that makes the project feel modern and impressive. It lowers the barrier for content creation in the game and yields eye-catching results (imagine showing judges a time-lapse of drawing a crude outline and then minting a beautiful AI-generated NFT from it in one minute – it’s a compelling story of what’s possible by combining AI + Web3).
- **“Wow” Factor:** The moment when the pet starts following the cursor on a random website tends to get a “wow” or at least a big smile. It showcases the concept of NFTs as more than static images – here they become interactive, persistent characters. This kind of user experience can make people actually want to engage daily (which ties back to retention via the quiz and points system). It also highlights culture: people form bonds with virtual pets (some team members likened it to having a Neopet or Pokemon that’s truly yours).
- **Cultural Relevance:** I see this project as a commentary on digital ownership and creativity. Players aren’t just collecting pets, they’re actively learning (through quizzes) and creating (through art) – it’s participatory culture. The ability to express oneself by designing accessories or naming your pet makes it personal. In a way, Tomodachi Pets could foster a community of user-generated content (imagine players trading the cool accessories they designed or holding pet fashion contests). This aligns well with the hackathon’s spirit of pushing new interactive, community-driven experiences on Sui.

In conclusion, Tomodachi Pets is a **fun, technically ambitious, and polished** hackathon project. It leverages Sui’s strengths (asset composability, fast transactions, upcoming storage solutions like Walrus) to create something more than a proof-of-concept – it’s an end-to-end product demo. I believe it can make a strong case for how Web3 can enrich entertainment and culture by empowering users to own, create, and play in ways not possible before.

# Tomodachi Pets: Setup & Development Guide

Tomodachi Pets is a virtual pet platform built on the Sui blockchain, featuring:

* A Next.js dApp for minting AI-generated pets and accessories as NFTs.
* A browser extension that displays your NFT pets on any website using a local backend.

This guide walks you through local installation for both the web app and browser extension.

🚀 Prerequisites

* Node.js (v16+ required, v18+ recommended)
* npm (comes with Node)
* Git
* Google Chrome (for the browser extension)

> Note: The web app runs on port 3000 and the extension backend on 3001 by default—ensure these ports are free, or adjust as needed.

⚙️ Environment Variables
Both projects require a `.env.local` file at the project root.

**Web App (tomodachi-pets) `.env.local`**

```env
# Load environment variables from .env.local
dotenv_config_path=.env.local

# OpenAI API Key (for AI image generation)
OPENAI_API_KEY=<YOUR_OPENAI_API_KEY>

# Sui RPC Endpoint (for Walrus client)
SUI_RPC_URL=<YOUR_SUI_RPC_URL>

# Walrus network: testnet or mainnet
WALRUS_NETWORK=<testnet|mainnet>
NEXT_PUBLIC_WALRUS_PUBLISHER_URL=<YOUR_WALRUS_PUBLISHER_URL>
NEXT_PUBLIC_WALRUS_BASE_URL=<YOUR_WALRUS_BASE_URL>
NEXT_PUBLIC_WALRUS_EPOCHS=<EPOCH_NUMBER>

# Signer secret (base64-encoded Ed25519 private key)
SUI_SECRET_KEY=<YOUR_BASE64_ED25519_PRIVATE_KEY>

# On-chain object IDs
NEXT_PUBLIC_PACKAGE_ID=<YOUR_PACKAGE_ID>
NEXT_PUBLIC_SCOREBOARD_ID=<YOUR_SCOREBOARD_ID>
NEXT_PUBLIC_MINT_RECORD_ID=<YOUR_MINT_RECORD_ID>
NEXT_PUBLIC_PET_NAMES_ID=<YOUR_PET_NAMES_ID>
NEXT_PUBLIC_EQUIPPED_ASSETS_ID=<YOUR_EQUIPPED_ASSETS_ID>
NEXT_PUBLIC_LAST_CHECKIN_ID=<YOUR_LAST_CHECKIN_ID>
```

**Extension (tomodachi-pets-extension) `.env.local`**

```env
# Load environment variables from .env.local
dotenv_config_path=.env.local

# OpenAI API Key (for image generation and backend use)
OPENAI_API_KEY=<YOUR_OPENAI_API_KEY>

# Sui RPC Endpoint (for Walrus client)
SUI_RPC_URL=<YOUR_SUI_RPC_URL>

# Walrus network: testnet or mainnet
WALRUS_NETWORK=<testnet|mainnet>
WALRUS_PUBLISHER_URL=<YOUR_WALRUS_PUBLISHER_URL>
WALRUS_BASE_URL=<YOUR_WALRUS_BASE_URL>
WALRUS_EPOCHS=<EPOCH_NUMBER>

# Signer secret (base64-encoded Ed25519 private key)
SUI_SECRET_KEY=<YOUR_BASE64_ED25519_PRIVATE_KEY>

# Move contract IDs
PACKAGE_ID=<YOUR_PACKAGE_ID>
SCOREBOARD_ID=<YOUR_SCOREBOARD_ID>
MINT_RECORD_ID=<YOUR_MINT_RECORD_ID>
PET_NAMES_ID=<YOUR_PET_NAMES_ID>
EQUIPPED_ASSETS_ID=<YOUR_EQUIPPED_ASSETS_ID>
LAST_CHECKIN_ID=<YOUR_LAST_CHECKIN_ID>
```

🖥️ Web App Setup (`tomodachi-pets`)

1. **Clone & Install:**

   ```bash
   git clone https://github.com/sumionochi/tomodachi-digital-pet.git tomodachi-pets
   cd tomodachi-pets
   npm install
   ```

2. **Set Environment Variables:**

   * Place your `.env.local` file in the project root.

3. **Start the App:**

   ```bash
   npm run dev
   ```

   This runs the Next.js app at [http://localhost:3000](http://localhost:3000).

🧩 Extension Setup (`tomodachi-pets-extension`)

1. **Clone & Install:**

   ```bash
   git clone https://github.com/sumionochi/tomodachi-digital-pet-extension.git tomodachi-pets-extension
   cd tomodachi-pets-extension
   npm install
   ```

2. **Set Environment Variables:**

   * Place your `.env.local` file in the project root.

3. **Build the Extension:**

   ```bash
   npm run build
   ```

   If you don’t have a build script, use:

   ```bash
   npx webpack
   ```

4. **Run the Backend Server:**

   ```bash
   node backend/server.js
   ```

   You should see:

   ```text
   Tomodachi backend listening on port 3001
   Ensure PACKAGE_ID is set. Current: 0xYourPackageID
   Ensure SCOREBOARD_ID is set. Current: 0xYourScoreboardID
   Using SUI_RPC: https://fullnode.testnet.sui.io:443
   ```

5. **Load the Extension in Chrome:**

   * Go to `chrome://extensions`
   * Enable Developer mode
   * Click Load unpacked and select the `tomodachi-pets-extension` folder (it must contain `manifest.json`)
   * The extension icon should appear in Chrome.

🕹️ Using Tomodachi Pets

**Web App:**

* Connect your Sui wallet, mint new pets/assets, and manage your collection.

**Browser Extension:**

1. Click the extension icon
2. Enter your Sui wallet address and select your pet/NFT
3. Toggle pet accessories as desired

> Note: The extension’s backend (`server.js`) must be running for the extension to fetch blockchain data.

🗂️ Project Structure & Flow

* **Web App:** Minting/managing pets/assets (on-chain, AI-generated art, wallet auth).
* **Extension:** Reads on-chain pet data and animates your pet on the web, fetching live state from your local backend.

📝 Tips & Troubleshooting

* **Ports:** If 3000/3001 are busy, change them in `.env.local` or with CLI flags.
* **Node Version:** Use Node.js 16 or 18+.
* **Dependencies:** Run npm install in both projects after cloning.
* **Extension Loading:** Always load the root of the extension (where `manifest.json` lives).
* **Chrome DevTools:** Use the console for extension logs or error debugging.

📣 Support

If you encounter issues, check:

* Environment variables: Make sure `.env.local` files are present and correct in each repo.
* Backend server: Ensure `node backend/server.js` is running for the extension.
* Chrome DevTools: Inspect logs for the extension.

For further assistance, open an issue in the respective GitHub repository.

